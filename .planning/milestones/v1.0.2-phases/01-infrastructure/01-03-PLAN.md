---
phase: 01-infrastructure
plan: 03
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - tests/fixtures/generate.ts
  - tests/fixtures/index.ts
  - tests/unit/parser.smoke.test.ts
  - .gitattributes
autonomous: true
requirements:
  - INFRA-03
  - INFRA-04

must_haves:
  truths:
    - "Running `npm run fixtures:generate` produces .xlsx files in tests/fixtures/ without errors"
    - "Each generated fixture has at least one formula cell (verified by read-back in the script)"
    - "The malformed.xlsx fixture is valid corrupt bytes (not a valid xlsx)"
    - "Running `npm test` passes the Vitest smoke test (SheetJS resolves through Vitest)"
    - "All seven fixture file paths are exported from tests/fixtures/index.ts as typed constants"
  artifacts:
    - path: "tests/fixtures/generate.ts"
      provides: "Programmatic fixture generator — creates 7 .xlsx test files via SheetJS"
      contains: "verify("
    - path: "tests/fixtures/index.ts"
      provides: "Typed fixture path exports for use in unit and E2E tests"
      exports: ["FIXTURES", "FixtureName"]
    - path: "tests/unit/parser.smoke.test.ts"
      provides: "Vitest smoke test — confirms SheetJS resolves correctly and inline fix works"
      contains: "import * as XLSX from 'xlsx'"
    - path: ".gitattributes"
      provides: "Marks generated .xlsx files as binary for clean git diffs"
      contains: "*.xlsx binary"
  key_links:
    - from: "tests/fixtures/generate.ts"
      to: "tests/fixtures/*.xlsx"
      via: "writeFileSync(join(OUT_DIR, ...))"
      pattern: "writeFileSync"
    - from: "tests/fixtures/index.ts"
      to: "tests/fixtures/*.xlsx"
      via: "resolve(__dirname, '...')"
      pattern: "resolve.*fixtures"
    - from: "tests/unit/parser.smoke.test.ts"
      to: "xlsx"
      via: "import * as XLSX from 'xlsx' (resolved via server.deps.inline)"
      pattern: "import.*XLSX.*from.*xlsx"
---

<objective>
Build the programmatic fixture generator, create all seven verified .xlsx test fixtures, write the typed fixture index, and add a Vitest smoke test that confirms SheetJS resolves correctly through the Vitest module pipeline.

Purpose: Test fixtures are the foundation of Phases 2, 3, and 4. Each fixture targets a specific parser behavior (cross-sheet refs, external refs, named ranges, empty workbooks, malformed files, large workbooks, circular refs). The smoke test proves the critical `server.deps.inline: ['xlsx']` fix from Plan 01 actually works — without it, every unit test in Phases 2 and 3 would fail silently.
Output: tests/fixtures/generate.ts, tests/fixtures/index.ts, tests/unit/parser.smoke.test.ts, .gitattributes, seven .xlsx files.
</objective>

<execution_context>
@C:/Users/chase/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/chase/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure/01-RESEARCH.md
@.planning/phases/01-infrastructure/01-01-SUMMARY.md
</context>

<interfaces>
<!-- From Plan 01: package.json has "fixtures:generate": "node tests/fixtures/generate.ts" -->
<!-- Node 24.13.0 natively strips TypeScript types — no tsx needed -->
<!-- SheetJS is already in dependencies: xlsx@^0.18.5 -->
<!-- vitest.config.ts has globals: true and server.deps.inline: ['xlsx'] -->
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create the fixture generator and generate all seven .xlsx files</name>
  <files>
    tests/fixtures/generate.ts
    tests/fixtures/index.ts
    .gitattributes
  </files>
  <action>
    Create the `tests/fixtures/` directory and `tests/fixtures/generate.ts`:

    ```typescript
    // tests/fixtures/generate.ts
    // Run via: node tests/fixtures/generate.ts
    // Node 24.13.0 natively strips TypeScript types — no tsx needed
    import * as XLSX from 'xlsx'
    import { writeFileSync, mkdirSync } from 'node:fs'
    import { join, dirname } from 'node:path'
    import { fileURLToPath } from 'node:url'

    const __filename = fileURLToPath(import.meta.url)
    const __dirname = dirname(__filename)
    const OUT_DIR = __dirname

    // Ensure output directory exists
    mkdirSync(OUT_DIR, { recursive: true })

    /**
     * Read-back verification: counts cells where cell.f is set.
     * Throws if count < expectedMinFormulas.
     * Critical: catches the aoa_to_sheet formula pitfall before files are written.
     */
    function verify(buf: Buffer, expectedMinFormulas: number, label: string): void {
      const wb = XLSX.read(buf, { type: 'buffer', cellFormula: true })
      let count = 0
      for (const name of wb.SheetNames) {
        const sheet = wb.Sheets[name]
        for (const key of Object.keys(sheet)) {
          if (!key.startsWith('!') && sheet[key]?.f) count++
        }
      }
      if (count < expectedMinFormulas) {
        throw new Error(`[${label}] Expected >= ${expectedMinFormulas} formula cells, found ${count}`)
      }
      console.log(`[${label}] OK — ${count} formula cells`)
    }

    // Fixture 1: Cross-sheet reference (Sheet1 -> Sheet2)
    function makeCrossSheetFixture(): void {
      const wb = XLSX.utils.book_new()
      const sheet1 = XLSX.utils.aoa_to_sheet([['placeholder']])
      // CRITICAL: set formula cell explicitly — aoa_to_sheet does NOT set cell.f
      sheet1['A1'] = { t: 'n', v: 0, f: 'Sheet2!A1' }
      const sheet2 = XLSX.utils.aoa_to_sheet([['source value']])
      XLSX.utils.book_append_sheet(wb, sheet1, 'Sheet1')
      XLSX.utils.book_append_sheet(wb, sheet2, 'Sheet2')
      const buf = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' }) as Buffer
      verify(buf, 1, 'cross-sheet')
      writeFileSync(join(OUT_DIR, 'cross-sheet.xlsx'), buf)
    }

    // Fixture 2: External file reference (bracketed filename format)
    function makeExternalRefFixture(): void {
      const wb = XLSX.utils.book_new()
      const sheet1 = XLSX.utils.aoa_to_sheet([['placeholder']])
      // Bracketed external ref: [External.xlsx]Prices!C3
      sheet1['A1'] = { t: 'n', v: 0, f: '[External.xlsx]Prices!C3' }
      XLSX.utils.book_append_sheet(wb, sheet1, 'Sheet1')
      const buf = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' }) as Buffer
      verify(buf, 1, 'external-ref')
      writeFileSync(join(OUT_DIR, 'external-ref.xlsx'), buf)
    }

    // Fixture 3: Named range
    function makeNamedRangeFixture(): void {
      const wb = XLSX.utils.book_new()
      const sheet1 = XLSX.utils.aoa_to_sheet([['placeholder']])
      sheet1['A1'] = { t: 'n', v: 0, f: 'Sheet2!A1' }
      const sheet2 = XLSX.utils.aoa_to_sheet([['source']])
      XLSX.utils.book_append_sheet(wb, sheet1, 'Sheet1')
      XLSX.utils.book_append_sheet(wb, sheet2, 'Sheet2')
      // Add named range via workbook Names table
      if (!wb.Workbook) wb.Workbook = { Names: [], Views: [], WBProps: {} }
      if (!wb.Workbook.Names) wb.Workbook.Names = []
      wb.Workbook.Names.push({ Name: 'MyRange', Ref: 'Sheet2!A1:A10', Sheet: undefined })
      const buf = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' }) as Buffer
      verify(buf, 1, 'named-ranges')
      writeFileSync(join(OUT_DIR, 'named-ranges.xlsx'), buf)
    }

    // Fixture 4: Empty workbook (no formulas)
    function makeEmptyFixture(): void {
      const wb = XLSX.utils.book_new()
      const sheet1 = XLSX.utils.aoa_to_sheet([['value', 'value2']])
      // Intentionally no formula cells — parser must return empty results
      XLSX.utils.book_append_sheet(wb, sheet1, 'Sheet1')
      const buf = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' }) as Buffer
      // No verify() call for empty — 0 formulas is the correct expected result
      console.log('[empty] OK — 0 formula cells (intentional)')
      writeFileSync(join(OUT_DIR, 'empty.xlsx'), buf)
    }

    // Fixture 5: Large workbook (100 sheets, each referencing the previous)
    function makeLargeFixture(): void {
      const wb = XLSX.utils.book_new()
      for (let i = 1; i <= 100; i++) {
        const sheet = XLSX.utils.aoa_to_sheet([['placeholder']])
        if (i > 1) {
          // Sheet2 references Sheet1, Sheet3 references Sheet2, etc.
          sheet['A1'] = { t: 'n', v: 0, f: `Sheet${i - 1}!A1` }
        }
        XLSX.utils.book_append_sheet(wb, sheet, `Sheet${i}`)
      }
      const buf = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' }) as Buffer
      verify(buf, 99, 'large')
      writeFileSync(join(OUT_DIR, 'large.xlsx'), buf)
    }

    // Fixture 6: Circular reference (Sheet1 -> Sheet2 -> Sheet1)
    function makeCircularFixture(): void {
      // SheetJS does not evaluate formulas — just stores formula strings
      // Parser must not infinite-loop when traversing circular ref chains
      const wb = XLSX.utils.book_new()
      const sheet1 = XLSX.utils.aoa_to_sheet([['placeholder']])
      sheet1['A1'] = { t: 'n', v: 0, f: 'Sheet2!A1' }
      const sheet2 = XLSX.utils.aoa_to_sheet([['placeholder']])
      sheet2['A1'] = { t: 'n', v: 0, f: 'Sheet1!A1' }
      XLSX.utils.book_append_sheet(wb, sheet1, 'Sheet1')
      XLSX.utils.book_append_sheet(wb, sheet2, 'Sheet2')
      const buf = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' }) as Buffer
      verify(buf, 2, 'circular')
      writeFileSync(join(OUT_DIR, 'circular.xlsx'), buf)
    }

    // Fixture 7: Malformed/corrupt file
    function makeMalformedFixture(): void {
      // SheetJS always writes valid xlsx — must write corrupt bytes manually
      // PK header is a valid zip signature prefix; rest is garbage
      const garbage = Buffer.from('PK\x03\x04this is not a valid xlsx file — corrupt for testing')
      writeFileSync(join(OUT_DIR, 'malformed.xlsx'), garbage)
      console.log('[malformed] OK — corrupt bytes written (not a valid xlsx)')
    }

    // Run all generators
    makeCrossSheetFixture()
    makeExternalRefFixture()
    makeNamedRangeFixture()
    makeEmptyFixture()
    makeLargeFixture()
    makeCircularFixture()
    makeMalformedFixture()
    console.log('All fixtures generated successfully.')
    ```

    Create `tests/fixtures/index.ts` — typed fixture path exports for Phase 2, 3, and 4 tests:

    ```typescript
    // tests/fixtures/index.ts
    // Typed fixture paths — import FIXTURES in tests to get correct absolute paths
    import { resolve } from 'node:path'
    import { fileURLToPath } from 'node:url'

    const FIXTURE_DIR = resolve(fileURLToPath(import.meta.url), '..')

    export const FIXTURES = {
      crossSheet: resolve(FIXTURE_DIR, 'cross-sheet.xlsx'),
      externalRef: resolve(FIXTURE_DIR, 'external-ref.xlsx'),
      namedRanges: resolve(FIXTURE_DIR, 'named-ranges.xlsx'),
      empty: resolve(FIXTURE_DIR, 'empty.xlsx'),
      large: resolve(FIXTURE_DIR, 'large.xlsx'),
      circular: resolve(FIXTURE_DIR, 'circular.xlsx'),
      malformed: resolve(FIXTURE_DIR, 'malformed.xlsx'),
    } as const

    export type FixtureName = keyof typeof FIXTURES
    ```

    Update `.gitattributes` (create if missing) to mark generated xlsx files as binary:

    ```
    # Mark generated test fixtures as binary files for clean git diffs
    tests/fixtures/*.xlsx binary
    ```

    This prevents git from trying to diff the binary content on every `git diff` call.

    Then run the generator:
    ```bash
    cd C:/Users/chase/projects/tangle && npm run fixtures:generate
    ```

    Expected output (all lines should appear):
    ```
    [cross-sheet] OK — 1 formula cells
    [external-ref] OK — 1 formula cells
    [named-ranges] OK — 1 formula cells
    [empty] OK — 0 formula cells (intentional)
    [large] OK — 99 formula cells
    [circular] OK — 2 formula cells
    [malformed] OK — corrupt bytes written (not a valid xlsx)
    All fixtures generated successfully.
    ```

    If any `verify()` call throws (formula count below expected), the generator exits with a non-zero code and reports which fixture failed. Do not proceed to Task 2 if the generator fails — investigate the formula cell construction for the failing fixture.
  </action>
  <verify>
    ```bash
    cd C:/Users/chase/projects/tangle && npm run fixtures:generate 2>&1
    ```
    Must exit 0 with all seven OK lines. Then confirm files exist:
    ```bash
    cd C:/Users/chase/projects/tangle && ls -la tests/fixtures/*.xlsx
    ```
    Must list 7 files: cross-sheet.xlsx, external-ref.xlsx, named-ranges.xlsx, empty.xlsx, large.xlsx, circular.xlsx, malformed.xlsx.
  </verify>
  <done>npm run fixtures:generate exits 0; seven .xlsx files exist in tests/fixtures/; each verified file logged "OK"; tests/fixtures/index.ts exports FIXTURES and FixtureName</done>
</task>

<task type="auto">
  <name>Task 2: Write Vitest smoke test and run the full unit test suite</name>
  <files>
    tests/unit/parser.smoke.test.ts
  </files>
  <action>
    Create `tests/unit/parser.smoke.test.ts`:

    ```typescript
    // tests/unit/parser.smoke.test.ts
    // Validates that SheetJS resolves correctly through Vitest's module pipeline.
    // This test specifically confirms the `server.deps.inline: ['xlsx']` fix in
    // vitest.config.ts works — without it, this import throws ERR_REQUIRE_ESM.
    import * as XLSX from 'xlsx'
    import { describe, it, expect } from 'vitest'

    describe('SheetJS import smoke test', () => {
      it('xlsx module resolves correctly via Vitest (server.deps.inline fix)', () => {
        // If server.deps.inline: ['xlsx'] is missing from vitest.config.ts,
        // this test will throw: "Cannot find module 'xlsx'" or "ERR_REQUIRE_ESM"
        const wb = XLSX.utils.book_new()
        expect(wb.SheetNames).toEqual([])
      })

      it('can create and read a workbook with a formula cell', () => {
        const wb = XLSX.utils.book_new()
        const ws: XLSX.WorkSheet = {}
        // Explicit formula cell construction — critical pattern for fixtures
        ws['A1'] = { t: 'n', v: 0, f: 'Sheet2!A1' }
        ws['!ref'] = 'A1:A1'
        XLSX.utils.book_append_sheet(wb, ws, 'Sheet1')
        XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet([['value']]), 'Sheet2')
        const buf = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' }) as Buffer
        const wb2 = XLSX.read(buf, { type: 'buffer', cellFormula: true })
        // Verify the formula round-trip preserved cell.f
        expect(wb2.Sheets['Sheet1']['A1'].f).toBe('Sheet2!A1')
      })

      it('can read the cross-sheet fixture and find formula cells', () => {
        // Reads the generated fixture to confirm fixtures:generate and Vitest cooperate
        import { FIXTURES } from '../fixtures/index'
        import { readFileSync } from 'node:fs'
        const buf = readFileSync(FIXTURES.crossSheet)
        const wb = XLSX.read(buf, { type: 'buffer', cellFormula: true })
        const sheet1 = wb.Sheets['Sheet1']
        expect(sheet1['A1'].f).toBe('Sheet2!A1')
      })
    })
    ```

    Wait — the inline import syntax above is wrong (imports must be top-level in ESM). Fix:

    ```typescript
    // tests/unit/parser.smoke.test.ts
    import * as XLSX from 'xlsx'
    import { readFileSync } from 'node:fs'
    import { describe, it, expect } from 'vitest'
    import { FIXTURES } from '../fixtures/index'

    describe('SheetJS import smoke test', () => {
      it('xlsx module resolves correctly via Vitest (server.deps.inline fix)', () => {
        const wb = XLSX.utils.book_new()
        expect(wb.SheetNames).toEqual([])
      })

      it('can create and read a workbook with a formula cell', () => {
        const wb = XLSX.utils.book_new()
        const ws: XLSX.WorkSheet = {}
        // Explicit formula cell construction — aoa_to_sheet does NOT preserve cell.f
        ws['A1'] = { t: 'n', v: 0, f: 'Sheet2!A1' }
        ws['!ref'] = 'A1:A1'
        XLSX.utils.book_append_sheet(wb, ws, 'Sheet1')
        XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet([['value']]), 'Sheet2')
        const buf = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' }) as Buffer
        const wb2 = XLSX.read(buf, { type: 'buffer', cellFormula: true })
        expect(wb2.Sheets['Sheet1']['A1'].f).toBe('Sheet2!A1')
      })

      it('cross-sheet fixture has a formula cell at Sheet1.A1', () => {
        // Verifies fixtures:generate produced a readable, formula-bearing file
        const buf = readFileSync(FIXTURES.crossSheet)
        const wb = XLSX.read(buf, { type: 'buffer', cellFormula: true })
        expect(wb.Sheets['Sheet1']['A1'].f).toBe('Sheet2!A1')
      })
    })
    ```

    Run the unit tests:
    ```bash
    cd C:/Users/chase/projects/tangle && npm test 2>&1
    ```

    All three tests must pass. If any fail:
    - "Cannot find module 'xlsx'" → `server.deps.inline: ['xlsx']` is missing from vitest.config.ts (Plan 01 Task 1 issue)
    - "cell.f is undefined" → formula cell was not constructed explicitly; verify generate.ts uses `ws['A1'] = { t: 'n', v: 0, f: '...' }`
    - "Cannot find module '../fixtures/index'" → fixtures/index.ts was not created in Task 1
  </action>
  <verify>
    ```bash
    cd C:/Users/chase/projects/tangle && npm test 2>&1
    ```
    Must show "3 passed" (or more) with zero failures. Exit code must be 0.

    Also verify coverage script works:
    ```bash
    cd C:/Users/chase/projects/tangle && npm run test:coverage 2>&1 | tail -10
    ```
    Must complete and create the coverage/ directory.
  </verify>
  <done>`npm test` exits 0 with all smoke tests passing; `npm run test:coverage` produces a coverage/ directory with HTML output; tests/unit/parser.smoke.test.ts exists with three passing assertions</done>
</task>

</tasks>

<verification>
```bash
cd C:/Users/chase/projects/tangle && npm run fixtures:generate 2>&1 | grep -E "OK|Error"
```
Must show seven OK lines, zero Error lines.

```bash
cd C:/Users/chase/projects/tangle && npm test 2>&1 | tail -5
```
Must show "X passed" with exit code 0.

```bash
cd C:/Users/chase/projects/tangle && ls tests/fixtures/*.xlsx | wc -l
```
Must print 7.

```bash
cd C:/Users/chase/projects/tangle && npm run test:coverage 2>&1 | tail -5 && ls coverage/ 2>/dev/null
```
Coverage directory must exist after test:coverage run.
</verification>

<success_criteria>
- `npm run fixtures:generate` exits 0 and all seven OK lines appear in output
- Seven .xlsx fixture files exist in tests/fixtures/
- tests/fixtures/index.ts exports FIXTURES (7 paths) and FixtureName type
- tests/unit/parser.smoke.test.ts has three passing tests (SheetJS import, formula round-trip, fixture read)
- `npm test` exits 0 with all tests passing
- `npm run test:coverage` produces coverage/ directory with HTML output
- .gitattributes marks tests/fixtures/*.xlsx as binary
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-03-SUMMARY.md` following the summary template.
</output>
