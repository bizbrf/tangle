# Architecture Research

**Domain:** Vitest + Playwright test suite for a Vite/React/TypeScript single-page app
**Researched:** 2026-02-27
**Confidence:** HIGH (Vitest and Playwright docs verified via official sources; React Flow testing guidance verified via reactflow.dev)

---

## Standard Architecture

### System Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                        UNIT TESTS (Vitest)                           │
│                    Environment: node (pure TS)                       │
├────────────────────────┬────────────────────────┬───────────────────┤
│   src/lib/parser.ts    │   src/lib/graph.ts     │   src/types.ts    │
│   - extractReferences  │   - buildGraph()        │   (shared types)  │
│   - extractNamedRanges │   - dagreLayout()       │                   │
│   - buildExternalLink  │   - groupedLayout()     │                   │
│   - parseWorkbook*     │   - buildOverviewGraph  │                   │
│   (*FileReader mock)   │   - computeClusterNodes │                   │
└────────────────────────┴────────────────────────┴───────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                       E2E TESTS (Playwright)                         │
│              Target: Vite dev server on localhost:5173               │
├──────────────────────────────────────────────────────────────────────┤
│  tests/e2e/                                                          │
│  ├── upload.spec.ts        (file upload + graph renders)             │
│  ├── features.spec.ts      (focus mode, hide/show, layout, filters)  │
│  └── error-handling.spec.ts(bad files, unsupported formats)          │
│                                                                      │
│  Fixture strategy: Playwright setInputFiles() with binary .xlsx      │
│  fixtures generated by a Node script using SheetJS                   │
└──────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                        TEST FIXTURES                                 │
├──────────────────────────────────────────────────────────────────────┤
│  tests/fixtures/                                                     │
│  ├── generate.ts           (script: writes .xlsx files via SheetJS)  │
│  ├── *.xlsx                (generated binary; gitignored or checked) │
│  └── index.ts              (exports fixture paths as constants)      │
└──────────────────────────────────────────────────────────────────────┘
```

### Component Responsibilities

| Component | Responsibility | Typical Implementation |
|-----------|----------------|------------------------|
| `vitest.config.ts` | Unit test runner config; extends vite.config; sets environment, setupFiles, coverage | Inline `test` block; provider: 'v8' |
| `playwright.config.ts` | E2E test config; `webServer` starts Vite; `baseURL`, browser projects | `webServer.command: 'npm run dev'` |
| `tests/unit/` | Pure TypeScript unit tests for lib functions | Vitest `describe`/`it`, no DOM needed |
| `tests/e2e/` | Full-app E2E tests with Playwright | `page.goto('/')`, file upload, assertions |
| `tests/fixtures/` | Generator script + output `.xlsx` files | SheetJS `book_new()`, `writeFile()` |
| `tests/helpers/` | Shared E2E helpers (upload helper, graph assertions) | Page Object Model classes |
| `src/lib/parser.ts` | Unit under test: `extractReferences`, `extractNamedRanges`, `buildExternalLinkMap` | Testable in isolation; FileReader must be bypassed |
| `src/lib/graph.ts` | Unit under test: `buildGraph`, `computeClusterNodes`, layout functions | Pure TypeScript; no DOM required |

---

## Recommended Project Structure

```
tests/
├── unit/
│   ├── parser.test.ts        # extractReferences, extractNamedRanges, buildExternalLinkMap
│   ├── parser.error.test.ts  # malformed input, circular refs, bad files
│   └── graph.test.ts         # buildGraph, layout functions, edge classification
├── e2e/
│   ├── upload.spec.ts        # core upload + graph render
│   ├── features.spec.ts      # focus mode, hide/show, layout, edge filters
│   └── error-handling.spec.ts# bad file, unsupported format
├── fixtures/
│   ├── generate.ts           # Node script to create .xlsx files
│   ├── index.ts              # exports fixture paths
│   └── *.xlsx                # generated binary fixtures
└── helpers/
    ├── upload.ts             # uploadFile() helper wrapping setInputFiles
    └── graph.ts              # GraphPage object model
vitest.config.ts
playwright.config.ts
```

### Structure Rationale

- **`tests/unit/`**: Collocated-by-concern (not mirroring src). The two lib files are the primary targets; splitting parser from parser.error keeps normal-path and error-path suites readable.
- **`tests/e2e/`**: Organized by user journey, not by component. Upload is the gating flow; features and error-handling are independent journeys.
- **`tests/fixtures/`**: Fixtures live next to tests that consume them, not in `src/`. The generator script keeps binary `.xlsx` files reproducible without storing large binaries in git history (generate on CI setup).
- **`tests/helpers/`**: A thin Page Object Model layer. Keeps `setInputFiles` boilerplate out of every spec file and makes assertions about the React Flow canvas reusable.

---

## Architectural Patterns

### Pattern 1: Bypass FileReader — Test the Inner Functions Directly

**What:** `parseWorkbook()` is FileReader-dependent (browser async API). The inner functions it calls — `extractReferences`, `extractNamedRanges`, `buildExternalLinkMap` — are pure synchronous functions that accept a `XLSX.WorkSheet` / `XLSX.WorkBook`. Test these directly by calling `XLSX.read()` with a `Buffer` in Node, bypassing FileReader entirely.

**When to use:** All unit tests for parser logic. FileReader should only be mocked as a last resort (for testing `parseWorkbook` rejection paths).

**Trade-offs:** Tests the logic but not the FileReader integration. That gap is covered by E2E tests which exercise the full file upload path.

**Example:**
```typescript
// tests/unit/parser.test.ts
import * as XLSX from 'xlsx';
import { readFileSync } from 'node:fs';
import { extractReferences } from '../../src/lib/parser'; // if exported; or test via parseWorkbook

const fixturePath = 'tests/fixtures/cross-sheet.xlsx';

test('detects cross-sheet reference', () => {
  const buf = readFileSync(fixturePath);
  const wb = XLSX.read(buf, { type: 'buffer', cellFormula: true, bookFiles: true });
  const sheet = wb.Sheets[wb.SheetNames[0]];
  // Call internal functions directly, or test via a thin wrapper
});
```

Note: `extractReferences` and `extractNamedRanges` are not currently exported from `parser.ts`. They will need to be exported, or tested via a thin exported wrapper, before unit tests can reach them directly.

### Pattern 2: Programmatic Fixture Generation with SheetJS

**What:** Use a Node.js script (`tests/fixtures/generate.ts`) that runs via `tsx` or `ts-node` to write `.xlsx` files covering specific reference patterns. Each fixture maps to one test scenario.

**When to use:** Before any test is written. The fixture generator is built first (Phase 1), and all subsequent tests consume its output.

**Trade-offs:** Adds a build step before tests. Fixtures are deterministic and reproducible. Avoids storing binary blobs in git — run `npm run fixtures:generate` on CI before the test step.

**Example:**
```typescript
// tests/fixtures/generate.ts
import * as XLSX from 'xlsx';
import { writeFileSync } from 'node:fs';

function makeCrossSheetFixture() {
  const wb = XLSX.utils.book_new();
  const sheet1 = XLSX.utils.aoa_to_sheet([['=Sheet2!A1']]);
  const sheet2 = XLSX.utils.aoa_to_sheet([['source value']]);
  // Inject formula string directly (SheetJS stores formulas in cell.f)
  sheet1['A1'].f = 'Sheet2!A1';
  XLSX.utils.book_append_sheet(wb, sheet1, 'Sheet1');
  XLSX.utils.book_append_sheet(wb, sheet2, 'Sheet2');
  const buf = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });
  writeFileSync('tests/fixtures/cross-sheet.xlsx', buf);
}
```

### Pattern 3: Playwright `setInputFiles` for File Upload

**What:** Playwright's `page.locator('input[type="file"]').setInputFiles(path)` injects a real file into the hidden file input without needing the OS file picker dialog. For the drag-drop zone, dispatch a synthetic `drop` event with a `DataTransfer` containing the file, or locate the hidden `<input>` that the drag zone wraps.

**When to use:** All E2E tests that need to upload an `.xlsx` file.

**Trade-offs:** `setInputFiles` is reliable. Drag-and-drop via `DataTransfer` is more fragile when the drop zone uses custom React synthetic event handlers; prefer locating the underlying file input if one exists.

**Example:**
```typescript
// tests/helpers/upload.ts
import type { Page } from '@playwright/test';
import * as path from 'node:path';
import { FIXTURES } from '../fixtures/index';

export async function uploadFile(page: Page, fixtureName: keyof typeof FIXTURES) {
  const filePath = path.resolve(FIXTURES[fixtureName]);
  const input = page.locator('input[type="file"]');
  await input.setInputFiles(filePath);
}
```

### Pattern 4: React Flow E2E — DOM Presence, Not Visual Pixels

**What:** React Flow renders nodes as `<div>` elements inside a `.react-flow__node` wrapper, even though the canvas feels SVG/canvas-like. Assert on DOM elements (node count, node labels, edge presence via `aria-label` or `data-id`) rather than pixel snapshots. The React Flow testing docs confirm Playwright needs no special setup — nodes are real DOM elements.

**When to use:** All E2E graph assertions.

**Trade-offs:** Skips visual regression (acceptable per PROJECT.md scope), but provides reliable, non-flaky assertions. Pixel snapshots are explicitly out of scope for v1 testing milestone.

**Example:**
```typescript
// tests/e2e/upload.spec.ts
test('graph renders sheet nodes after upload', async ({ page }) => {
  await page.goto('/');
  await uploadFile(page, 'crossSheet');
  // React Flow wraps each node in this class
  await expect(page.locator('.react-flow__node')).toHaveCount(2);
  await expect(page.locator('.react-flow__node').first()).toContainText('Sheet1');
});
```

---

## Data Flow

### Fixture → Unit Test Flow

```
tests/fixtures/generate.ts (Node script)
    ↓ writes
tests/fixtures/*.xlsx  (binary files)
    ↓ readFileSync(path)
XLSX.read(buffer, { type: 'buffer', cellFormula: true, bookFiles: true })
    ↓ produces
XLSX.WorkBook  →  extractReferences() / extractNamedRanges() / buildExternalLinkMap()
    ↓ returns
SheetReference[] / NamedRange[] / Map<string,string>
    ↓ asserted in
tests/unit/parser.test.ts
```

### Fixture → E2E Flow

```
tests/fixtures/*.xlsx
    ↓ path passed to
Playwright setInputFiles()
    ↓ triggers
App FilePanel drop/change handler → parseWorkbook() → FileReader.readAsArrayBuffer()
    ↓ produces
WorkbookFile[] → buildGraph() → React Flow nodes/edges (DOM)
    ↓ asserted in
tests/e2e/*.spec.ts via page.locator()
```

### Key Data Flows

1. **Fixture generation:** `generate.ts` script runs once (or on CI setup), writes `.xlsx` files using `XLSX.write()`. All subsequent test runs consume the same deterministic files.
2. **Unit test path:** `readFileSync` → `XLSX.read()` → internal parser functions → assert on returned `SheetReference[]`. No FileReader, no DOM, no React.
3. **E2E path:** Playwright `setInputFiles()` → browser's FileReader executes inside the live Vite-served app → full React render → DOM assertions.
4. **Coverage path:** Vitest instrumentation (v8 provider) runs during `npm run test:unit`, generates an HTML/LCOV report from `tests/unit/` runs over `src/lib/`.

---

## Build Order (What to Set Up First)

The following order respects dependency relationships:

1. **Fixture generator first** — All other tests depend on `.xlsx` files. Write `tests/fixtures/generate.ts`, add `npm run fixtures:generate` script, run it to produce binaries. Unblocks both unit and E2E tracks.

2. **Vitest config + unit tests for `graph.ts`** — `buildGraph()` and layout functions are pure TypeScript with no browser API dependencies. Zero mocking required. Fastest path to running tests and validating the config. Install: `vitest`, `@vitest/coverage-v8`.

3. **Export internal parser functions + unit tests for `parser.ts`** — Requires exporting `extractReferences`, `extractNamedRanges`, `buildExternalLinkMap` from `parser.ts`. Then write normal-path and error-path suites. These tests use `node` environment (no jsdom needed — SheetJS runs fine in Node).

4. **Playwright config + webServer** — Configure `playwright.config.ts` with `webServer: { command: 'npm run dev', url: 'http://localhost:5173', reuseExistingServer: !process.env.CI }`. Write `tests/helpers/upload.ts`. Install: `@playwright/test`, `npx playwright install`.

5. **E2E upload + graph render** — Core flow test: upload a fixture, assert nodes appear. This validates the full pipeline and unblocks all other E2E tests.

6. **E2E feature interactions** — Focus mode, hide/show, layout switching, edge filters. Each feature is an independent E2E spec; order within this step is flexible.

7. **E2E error handling** — Upload a non-Excel file, upload a zero-byte file. Validates the `parseWorkbook` rejection path end-to-end.

8. **CI integration** — Add two steps to CI: (a) `npm run fixtures:generate` before `npm test`, (b) `npm run test:e2e` with Playwright in headless Chromium.

---

## Configuration Details

### `vitest.config.ts`

```typescript
/// <reference types="vitest/config" />
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'node',       // parser.ts and graph.ts need no DOM
    include: ['tests/unit/**/*.test.ts'],
    coverage: {
      provider: 'v8',
      include: ['src/lib/**'],
      reporter: ['text', 'html', 'json-summary'],
    },
  },
});
```

### `playwright.config.ts`

```typescript
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: 'tests/e2e',
  use: {
    baseURL: 'http://localhost:5173',
  },
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
  },
  projects: [
    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
  ],
});
```

---

## Anti-Patterns

### Anti-Pattern 1: Testing `parseWorkbook()` Directly in Unit Tests

**What people do:** Mock `FileReader` in jsdom to test `parseWorkbook()` end-to-end in unit tests. This requires `// @vitest-environment jsdom` plus a FileReader mock.

**Why it's wrong:** The FileReader mock is fragile — jsdom's ArrayBuffer handling has known compatibility issues with Vitest (vitest-dev/vitest#1703). The actual reference extraction logic lives in `extractReferences`, not in the FileReader callback. Testing the outer shell obscures the signal.

**Do this instead:** Export and directly test `extractReferences`, `extractNamedRanges`, `buildExternalLinkMap`. Let E2E tests cover the FileReader path via real browser execution.

### Anti-Pattern 2: Visual/Pixel Snapshot Tests for the Graph

**What people do:** Use `expect(page).toHaveScreenshot()` on the React Flow canvas to assert graph correctness.

**Why it's wrong:** React Flow layout is non-deterministic (Dagre uses floating point; node positions vary by pixel). Snapshots would need per-platform baselines and would fail on any layout change. PROJECT.md explicitly excludes visual regression from this milestone.

**Do this instead:** Assert on DOM elements — `.react-flow__node` count, node label text, edge presence via `data-id`. These are deterministic and resilient to layout changes.

### Anti-Pattern 3: Storing Binary `.xlsx` Fixtures Without a Generator

**What people do:** Commit manually-created `.xlsx` files to git as opaque blobs.

**Why it's wrong:** Binary blobs are not diff-able, hard to update, and their content is opaque. When a fixture needs a new reference pattern, there's no documented way to reproduce it.

**Do this instead:** Commit only `generate.ts`. The script is readable, version-controlled source of truth. Add the script to CI's pre-test step. Generated `.xlsx` files can be gitignored or committed as outputs of a known script.

### Anti-Pattern 4: Running E2E Tests Against a Production Build Only

**What people do:** Run `vite build` then `vite preview` before Playwright to avoid Vite dev server overhead in CI.

**Why it's wrong:** The production build strips HMR and development-only React error boundaries. For a test milestone, the dev server is fine — it starts in under 2 seconds. Production build testing is a separate CI job concern.

**Do this instead:** Use `npm run dev` in `playwright.config.ts` `webServer.command`. Use `reuseExistingServer: !process.env.CI` to avoid double-starting in local dev.

---

## Integration Points

### Internal Boundaries

| Boundary | Communication | Notes |
|----------|---------------|-------|
| Unit tests ↔ `src/lib/parser.ts` | Direct import; `extractReferences` etc. must be exported | Currently these are unexported; exporting them is the enabling change |
| Unit tests ↔ `src/lib/graph.ts` | Direct import; `buildGraph`, `computeClusterNodes` already exported | No change needed |
| Unit tests ↔ `tests/fixtures/` | `readFileSync` + `XLSX.read()` | Node environment; no browser APIs involved |
| E2E tests ↔ Vite dev server | Playwright `webServer` auto-starts on `npm run test:e2e` | Port 5173; `reuseExistingServer` for local dev |
| E2E tests ↔ `tests/fixtures/` | `setInputFiles(path)` | Playwright resolves path relative to project root |
| `generate.ts` ↔ `xlsx` package | Direct import (already in `dependencies`) | Run via `tsx tests/fixtures/generate.ts` |

### CI Pipeline Shape

```
CI Job: test
  1. npm ci
  2. npx tsx tests/fixtures/generate.ts    ← generate .xlsx binaries
  3. npm run test:unit -- --coverage       ← Vitest unit + coverage
  4. npx playwright install --with-deps chromium
  5. npm run test:e2e                      ← Playwright E2E (headless)
```

---

## Scaling Considerations

| Scale | Architecture Adjustments |
|-------|--------------------------|
| Current (zero tests) | This structure; all setup from scratch |
| After milestone (50-100 tests) | Add `@vitest/ui` for local test exploration; keep E2E to Chromium-only |
| Future (multi-browser, Tauri) | Add Firefox/WebKit Playwright projects; add a separate Tauri E2E project using Playwright's `tauri-driver` integration |

### Scaling Priorities

1. **First bottleneck:** E2E test duration. React Flow animations and graph layout are synchronous but Playwright's `waitFor` calls add latency. Mitigate by asserting presence of specific node labels rather than `waitForTimeout`. Use `page.waitForSelector('.react-flow__node')` with a count assertion.
2. **Second bottleneck:** Fixture diversity. A small fixture set (5-7 files) covers most parser paths; the real explosion risk is adding fixtures for every edge case without a naming scheme. Keep the fixture index (`tests/fixtures/index.ts`) as the single registry.

---

## Sources

- Vitest configuration: https://vitest.dev/guide/ (HIGH confidence — official docs)
- Vitest environments (jsdom/happy-dom/browser mode): https://vitest.dev/guide/environment (HIGH confidence — official docs)
- Vitest coverage with v8: https://vitest.dev/guide/coverage.html (HIGH confidence — official docs)
- React Flow testing guidance: https://reactflow.dev/learn/advanced-use/testing (HIGH confidence — official library docs)
- Playwright file upload via `setInputFiles`: https://playwright.dev/docs/api/class-locator (HIGH confidence — official docs)
- Playwright `webServer` config: https://playwright.dev/docs/test-webserver (HIGH confidence — official docs)
- Playwright fixtures / POM pattern: https://playwright.dev/docs/test-fixtures (HIGH confidence — official docs)
- Playwright drag-and-drop file upload (React): https://github.com/microsoft/playwright/issues/5001 (MEDIUM confidence — community discussion with confirmed patterns)
- Vitest jsdom ArrayBuffer compatibility issue: https://github.com/vitest-dev/vitest/issues/1703 (MEDIUM confidence — tracked issue)
- SheetJS programmatic workbook creation: https://docs.sheetjs.com/docs/getting-started/examples/export/ (HIGH confidence — official SheetJS docs)

---
*Architecture research for: Vitest + Playwright test suite on Tangle (Vite/React/TypeScript)*
*Researched: 2026-02-27*
