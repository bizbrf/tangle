---
phase: 02-parser-unit-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/parser.ts
  - tests/unit/parser.test.ts
autonomous: true
requirements:
  - PARSE-01
  - PARSE-02
  - PARSE-03
  - PARSE-04
  - PARSE-05
  - PARSE-06
  - PARSE-07
  - PARSE-08

must_haves:
  truths:
    - "`extractReferences`, `extractNamedRanges`, and `buildExternalLinkMap` are importable from `src/lib/parser.ts` without TypeScript errors"
    - "`npm test` passes all tests in `tests/unit/parser.test.ts` — cross-sheet (unquoted and quoted), external file (bracketed filename and numeric index), named ranges (detection and dedup), and workload metrics all green"
    - "SUM() and other Excel built-in function names are not detected as named range references"
    - "A formula with the same named range used twice in one cell emits exactly one edge for that named range"
  artifacts:
    - path: "src/lib/parser.ts"
      provides: "Parser module with 3 newly exported internal functions"
      exports: ["extractReferences", "extractNamedRanges", "buildExternalLinkMap", "parseWorkbook", "EXCEL_EXTENSIONS", "EXCEL_EXT_RE"]
    - path: "tests/unit/parser.test.ts"
      provides: "Happy-path unit tests for all 8 PARSE requirements"
      contains: "PARSE-02"
  key_links:
    - from: "tests/unit/parser.test.ts"
      to: "src/lib/parser.ts"
      via: "import { extractReferences, extractNamedRanges, buildExternalLinkMap } from '../../src/lib/parser'"
      pattern: "import.*extractReferences.*from.*parser"
    - from: "tests/unit/parser.test.ts"
      to: "tests/fixtures/index.ts"
      via: "import { FIXTURES } from '../fixtures/index'"
      pattern: "import.*FIXTURES.*from.*fixtures"
---

<objective>
Export three private functions from `parser.ts` so they can be unit-tested in isolation, then write `tests/unit/parser.test.ts` covering all happy-path reference extraction behaviors: unquoted and quoted cross-sheet refs, external file refs (bracketed filename and numeric index), named range detection and dedup, and workload metrics.

Purpose: `extractReferences()` is the core logic of the entire application — if it misses a reference or miscounts metrics, the graph is wrong. Unit testing it in isolation (bypassing `parseWorkbook()`'s FileReader dependency) gives fast, deterministic coverage of every code path.
Output: Modified `src/lib/parser.ts` (3 new exports), new `tests/unit/parser.test.ts` (PARSE-01 through PARSE-08).
</objective>

<execution_context>
@C:/Users/chase/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/chase/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-parser-unit-tests/02-RESEARCH.md
</context>

<interfaces>
<!-- From src/lib/parser.ts — functions being exported (add `export` keyword only, no other change): -->

<!-- Line 48: -->
<!-- function buildExternalLinkMap(wb: XLSX.WorkBook): Map<string, string> -->
<!-- Reads wb.files (raw zip entries) for xl/externalLinks/_rels/externalLink{N}.xml.rels -->
<!-- Returns Map<"1", "Assumptions.xlsx"> etc. -->

<!-- Line 86: -->
<!-- function extractNamedRanges(wb: XLSX.WorkBook): NamedRange[] -->
<!-- Reads wb.Workbook?.Names, skips _xlnm.* built-ins -->
<!-- Returns NamedRange[] with { name, ref, targetSheet, targetWorkbook, cells, scope, scopeSheet } -->

<!-- Line 134: -->
<!-- function extractReferences( -->
<!--   sheet: XLSX.WorkSheet, -->
<!--   sheetName: string, -->
<!--   workbookName: string, -->
<!--   linkMap: Map<string, string>, -->
<!--   namedRangeMap: Map<string, NamedRange>, -->
<!-- ): { references: SheetReference[]; workload: SheetWorkload } -->

<!-- From src/types.ts — types used in assertions: -->
<!-- SheetReference: { targetWorkbook: string | null, targetSheet: string, cells: string[], formula: string, sourceCell: string, namedRangeName?: string } -->
<!-- SheetWorkload: { totalFormulas: number, withinSheetRefs: number, crossSheetRefs: number, crossFileRefs: number } -->
<!-- NamedRange: { name: string, ref: string, targetSheet: string, targetWorkbook: string | null, cells: string, scope: 'workbook' | 'sheet', scopeSheet?: string } -->

<!-- From tests/fixtures/index.ts — fixture paths: -->
<!-- FIXTURES.crossSheet    → tests/fixtures/cross-sheet.xlsx    (Sheet1.A1.f = 'Sheet2!A1') -->
<!-- FIXTURES.externalRef   → tests/fixtures/external-ref.xlsx   (Sheet1.A1.f = '[External.xlsx]Prices!C3') -->
<!-- FIXTURES.namedRanges   → tests/fixtures/named-ranges.xlsx   (defines MyRange but no formula USES it — use inline wb for PARSE-06/07) -->

<!-- CRITICAL PITFALLS (from RESEARCH.md): -->
<!-- 1. Every XLSX.read() call MUST include { type: 'buffer', cellFormula: true } or cell.f is undefined -->
<!-- 2. Inline formula cells MUST use ws['A1'] = { t: 'n', v: 0, f: 'Formula' } — aoa_to_sheet never sets cell.f -->
<!-- 3. withinSheetRefs: formula Sheet1!A1 when sheetName='Sheet1' counts as withinSheetRefs, NOT crossSheetRefs -->
<!-- 4. Error message for corrupt files varies — use .rejects.toThrow() without a specific message string -->
<!-- 5. globals: true is set in vitest.config.ts — but beforeAll/beforeEach still need explicit import from 'vitest' -->
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Export three internal functions from parser.ts</name>
  <files>
    src/lib/parser.ts
  </files>
  <action>
    Add the `export` keyword to exactly three function declarations in `src/lib/parser.ts`. This is the only source code change in the entire Phase 2 milestone.

    **Change 1** — line ~48, `buildExternalLinkMap`:
    ```typescript
    // Before:
    function buildExternalLinkMap(wb: XLSX.WorkBook): Map<string, string> {

    // After:
    export function buildExternalLinkMap(wb: XLSX.WorkBook): Map<string, string> {
    ```

    **Change 2** — line ~86, `extractNamedRanges`:
    ```typescript
    // Before:
    function extractNamedRanges(wb: XLSX.WorkBook): NamedRange[] {

    // After:
    export function extractNamedRanges(wb: XLSX.WorkBook): NamedRange[] {
    ```

    **Change 3** — line ~134, `extractReferences`:
    ```typescript
    // Before:
    function extractReferences(

    // After:
    export function extractReferences(
    ```

    No other changes. Do not touch any other part of `parser.ts`. The `readFileEntry` helper function should remain private (not exported — tests never call it directly).

    After editing, verify TypeScript compiles cleanly:
    ```bash
    cd C:/Users/chase/projects/tangle && npx tsc --noEmit 2>&1
    ```
    Must exit 0 with zero errors. If tsc reports errors, they are almost certainly pre-existing (not caused by adding `export`) — check that the export keyword was placed correctly on the function declaration line.
  </action>
  <verify>
    ```bash
    cd C:/Users/chase/projects/tangle && npx tsc --noEmit 2>&1
    ```
    Must exit 0.

    ```bash
    cd C:/Users/chase/projects/tangle && grep -n "^export function" src/lib/parser.ts
    ```
    Must show exactly 4 lines: `buildExternalLinkMap`, `extractNamedRanges`, `extractReferences`, and `parseWorkbook` (the existing public export).
  </verify>
  <done>`npx tsc --noEmit` exits 0; four `export function` declarations exist in parser.ts; no other lines changed</done>
</task>

<task type="auto">
  <name>Task 2: Write parser.test.ts covering PARSE-01 through PARSE-08</name>
  <files>
    tests/unit/parser.test.ts
  </files>
  <action>
    Create `tests/unit/parser.test.ts`. This file uses the default `node` environment (no jsdom annotation needed). Load fixtures with `readFileSync` + `XLSX.read()`. Construct inline workbooks for tests that need specific formula shapes not present in fixture files (PARSE-03, PARSE-04, PARSE-06, PARSE-07).

    ```typescript
    // tests/unit/parser.test.ts
    // Environment: node (default from vitest.config.ts — no @vitest-environment annotation)
    // Covers: PARSE-01, PARSE-02, PARSE-03, PARSE-04, PARSE-05, PARSE-06, PARSE-07, PARSE-08
    import * as XLSX from 'xlsx'
    import { readFileSync } from 'node:fs'
    import { describe, it, expect, beforeAll } from 'vitest'
    import { FIXTURES } from '../fixtures/index'
    import { extractReferences, extractNamedRanges, buildExternalLinkMap } from '../../src/lib/parser'

    // ── PARSE-01: Functions are importable ───────────────────────────────────────
    // Verified implicitly: if this file loads without error, the exports exist.
    // Explicit check in the first test below.

    // ── PARSE-02 + PARSE-08: Unquoted cross-sheet ref + workload metrics ─────────
    describe('extractReferences — unquoted cross-sheet ref (PARSE-02, PARSE-08)', () => {
      let wb: XLSX.WorkBook

      beforeAll(() => {
        // cross-sheet.xlsx: Sheet1.A1.f = 'Sheet2!A1' (unquoted, no spaces in name)
        const buf = readFileSync(FIXTURES.crossSheet)
        wb = XLSX.read(buf, { type: 'buffer', cellFormula: true })
      })

      it('PARSE-01: extractReferences is exported and callable', () => {
        // If import above succeeded, the function exists. Call it to confirm runtime shape.
        const result = extractReferences(wb.Sheets['Sheet1'], 'Sheet1', 'test.xlsx', new Map(), new Map())
        expect(result).toHaveProperty('references')
        expect(result).toHaveProperty('workload')
      })

      it('PARSE-02: detects unquoted cross-sheet reference SheetName!A1', () => {
        const { references } = extractReferences(
          wb.Sheets['Sheet1'], 'Sheet1', 'test.xlsx', new Map(), new Map()
        )
        expect(references).toHaveLength(1)
        expect(references[0].targetSheet).toBe('Sheet2')
        expect(references[0].targetWorkbook).toBeNull()
        expect(references[0].cells).toContain('A1')
      })

      it('PARSE-08: workload metrics are correct for one cross-sheet formula', () => {
        const { workload } = extractReferences(
          wb.Sheets['Sheet1'], 'Sheet1', 'test.xlsx', new Map(), new Map()
        )
        expect(workload.totalFormulas).toBe(1)
        expect(workload.crossSheetRefs).toBe(1)
        expect(workload.crossFileRefs).toBe(0)
        expect(workload.withinSheetRefs).toBe(0)
      })
    })

    // ── PARSE-03: Quoted cross-sheet ref (sheet name with spaces) ────────────────
    describe('extractReferences — quoted cross-sheet ref (PARSE-03)', () => {
      let wb: XLSX.WorkBook

      beforeAll(() => {
        // Inline workbook — cross-sheet.xlsx uses unquoted names.
        // PARSE-03 requires 'Sheet Name'!A1:B2 (spaces require quoting in Excel).
        const wbRaw = XLSX.utils.book_new()
        const sheet1: XLSX.WorkSheet = {}
        // Formula references a sheet whose name contains a space — must be quoted
        sheet1['A1'] = { t: 'n', v: 0, f: "'Sheet Name'!A1:B2" }
        sheet1['!ref'] = 'A1:A1'
        const sheetWithSpace = XLSX.utils.aoa_to_sheet([['src', 1]])
        XLSX.utils.book_append_sheet(wbRaw, sheet1, 'Sheet1')
        XLSX.utils.book_append_sheet(wbRaw, sheetWithSpace, 'Sheet Name')
        // Write + read back to ensure cell.f survives round-trip
        const buf = XLSX.write(wbRaw, { type: 'buffer', bookType: 'xlsx' }) as Buffer
        wb = XLSX.read(buf, { type: 'buffer', cellFormula: true })
      })

      it("PARSE-03: detects quoted cross-sheet reference 'Sheet Name'!A1:B2", () => {
        const { references } = extractReferences(
          wb.Sheets['Sheet1'], 'Sheet1', 'test.xlsx', new Map(), new Map()
        )
        expect(references).toHaveLength(1)
        expect(references[0].targetSheet).toBe('Sheet Name')
        expect(references[0].targetWorkbook).toBeNull()
        expect(references[0].cells).toContain('A1:B2')
      })
    })

    // ── PARSE-04: Numeric external link index resolution ─────────────────────────
    describe('extractReferences — numeric external link index (PARSE-04)', () => {
      it('PARSE-04: resolves [1]Prices!C3 to actual filename via linkMap', () => {
        // Inline sheet — SheetJS programmatic writes do NOT produce xl/externalLinks/_rels/
        // entries, so numeric index format cannot come from a fixture file.
        // Pass a mock linkMap directly to test the resolution path.
        const sheet: XLSX.WorkSheet = {}
        sheet['A1'] = { t: 'n', v: 0, f: '[1]Prices!C3' }
        sheet['!ref'] = 'A1:A1'
        const linkMap = new Map([['1', 'Assumptions.xlsx']])
        const { references } = extractReferences(sheet, 'Sheet1', 'Source.xlsx', linkMap, new Map())
        expect(references).toHaveLength(1)
        expect(references[0].targetWorkbook).toBe('Assumptions.xlsx')
        expect(references[0].targetSheet).toBe('Prices')
      })

      it('PARSE-04: buildExternalLinkMap is exported and returns a Map', () => {
        // Smoke-test the export itself with an empty workbook (no externalLinks)
        const wb = XLSX.utils.book_new()
        XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet([['val']]), 'Sheet1')
        const map = buildExternalLinkMap(wb)
        expect(map).toBeInstanceOf(Map)
        // Empty workbook has no external links
        expect(map.size).toBe(0)
      })
    })

    // ── PARSE-05: Bracketed filename external ref ─────────────────────────────────
    describe('extractReferences — bracketed filename external ref (PARSE-05)', () => {
      let wb: XLSX.WorkBook

      beforeAll(() => {
        // external-ref.xlsx: Sheet1.A1.f = '[External.xlsx]Prices!C3'
        const buf = readFileSync(FIXTURES.externalRef)
        wb = XLSX.read(buf, { type: 'buffer', cellFormula: true })
      })

      it('PARSE-05: detects [External.xlsx]Prices!C3 as a cross-file reference', () => {
        const { references } = extractReferences(
          wb.Sheets['Sheet1'], 'Sheet1', 'test.xlsx', new Map(), new Map()
        )
        expect(references).toHaveLength(1)
        expect(references[0].targetWorkbook).toBe('External.xlsx')
        expect(references[0].targetSheet).toBe('Prices')
        expect(references[0].cells).toContain('C3')
      })

      it('PARSE-08: crossFileRefs metric is incremented for external file reference', () => {
        const { workload } = extractReferences(
          wb.Sheets['Sheet1'], 'Sheet1', 'test.xlsx', new Map(), new Map()
        )
        expect(workload.totalFormulas).toBe(1)
        expect(workload.crossFileRefs).toBe(1)
        expect(workload.crossSheetRefs).toBe(0)
        expect(workload.withinSheetRefs).toBe(0)
      })
    })

    // ── PARSE-06 + PARSE-07: Named range detection and dedup ──────────────────────
    describe('extractReferences — named ranges (PARSE-06, PARSE-07)', () => {
      let wb: XLSX.WorkBook

      beforeAll(() => {
        // Inline workbook — named-ranges.xlsx only DEFINES MyRange but has no formula
        // that references it by name. Construct inline for named range USAGE tests.
        const wbRaw = XLSX.utils.book_new()
        const sheet1: XLSX.WorkSheet = {}
        sheet1['A1'] = { t: 'n', v: 0, f: 'MyRange' }              // named range reference
        sheet1['A2'] = { t: 'n', v: 0, f: 'SUM(Sheet2!B1:B5)' }    // function call — NOT a named range
        sheet1['A3'] = { t: 'n', v: 0, f: 'MyRange+MyRange' }       // same named range twice
        sheet1['!ref'] = 'A1:A3'
        const sheet2 = XLSX.utils.aoa_to_sheet([['src', 1, 2, 3, 4, 5]])
        XLSX.utils.book_append_sheet(wbRaw, sheet1, 'Sheet1')
        XLSX.utils.book_append_sheet(wbRaw, sheet2, 'Sheet2')
        if (!wbRaw.Workbook) wbRaw.Workbook = { Names: [], Views: [], WBProps: {} }
        wbRaw.Workbook.Names = [{ Name: 'MyRange', Ref: 'Sheet2!A1:A10', Sheet: undefined }]
        // Write + read back to preserve cell.f strings
        const buf = XLSX.write(wbRaw, { type: 'buffer', bookType: 'xlsx' }) as Buffer
        wb = XLSX.read(buf, { type: 'buffer', cellFormula: true })
      })

      it('PARSE-06: extractNamedRanges is exported and returns NamedRange[]', () => {
        const namedRanges = extractNamedRanges(wb)
        expect(Array.isArray(namedRanges)).toBe(true)
        expect(namedRanges).toHaveLength(1)
        expect(namedRanges[0].name).toBe('MyRange')
        expect(namedRanges[0].targetSheet).toBe('Sheet2')
      })

      it('PARSE-06: detects named range reference in formula (MyRange → Sheet2)', () => {
        const namedRanges = extractNamedRanges(wb)
        const namedRangeMap = new Map(namedRanges.map(nr => [nr.name.toLowerCase(), nr]))
        const { references } = extractReferences(
          wb.Sheets['Sheet1'], 'Sheet1', 'test.xlsx', new Map(), namedRangeMap
        )
        const nrRef = references.find(r => r.namedRangeName === 'MyRange')
        expect(nrRef).toBeDefined()
        expect(nrRef?.targetSheet).toBe('Sheet2')
        expect(nrRef?.namedRangeName).toBe('MyRange')
      })

      it('PARSE-06: SUM() is NOT detected as a named range reference', () => {
        const namedRanges = extractNamedRanges(wb)
        const namedRangeMap = new Map(namedRanges.map(nr => [nr.name.toLowerCase(), nr]))
        const { references } = extractReferences(
          wb.Sheets['Sheet1'], 'Sheet1', 'test.xlsx', new Map(), namedRangeMap
        )
        // No reference should have namedRangeName = 'SUM'
        const sumRef = references.find(r => r.namedRangeName === 'SUM')
        expect(sumRef).toBeUndefined()
      })

      it('PARSE-07: duplicate named range in one formula emits exactly one edge', () => {
        // A3 = 'MyRange+MyRange' — should produce exactly 1 ref for MyRange, not 2
        const namedRanges = extractNamedRanges(wb)
        const namedRangeMap = new Map(namedRanges.map(nr => [nr.name.toLowerCase(), nr]))
        const { references } = extractReferences(
          wb.Sheets['Sheet1'], 'Sheet1', 'test.xlsx', new Map(), namedRangeMap
        )
        const a3Refs = references.filter(r => r.sourceCell === 'A3')
        const myRangeRefs = a3Refs.filter(r => r.namedRangeName === 'MyRange')
        expect(myRangeRefs).toHaveLength(1)
      })
    })
    ```

    Run tests to confirm all pass:
    ```bash
    cd C:/Users/chase/projects/tangle && npm test 2>&1
    ```

    Troubleshooting:
    - "Cannot find module '../../src/lib/parser'" with named export → Task 1 export was not saved correctly; re-check parser.ts
    - references array is empty when expecting 1 → Missing `cellFormula: true` in XLSX.read(), or formula cell built with aoa_to_sheet (cell.f not set)
    - crossSheetRefs is 0 when expected 1 → Formula sheet name matches sheetName argument (self-ref); verify formula targets a DIFFERENT sheet
    - myRangeRefs.length is 2 instead of 1 → Dedup key collision; check that sourceCell='A3' filter is correct
  </action>
  <verify>
    <automated>
      cd C:/Users/chase/projects/tangle && npm test 2>&1
    </automated>
    Must show all tests passing (the 3 smoke tests from Phase 1 plus all new parser.test.ts tests). Zero failures. Exit code 0.

    Count new tests added:
    ```bash
    cd C:/Users/chase/projects/tangle && npm test 2>&1 | grep -E "passed|failed"
    ```
    Must show at least 10 passed (3 smoke + 7+ new parser tests), 0 failed.
  </verify>
  <done>`npm test` exits 0 with all tests passing; `tests/unit/parser.test.ts` covers PARSE-01 through PARSE-08 with at least one assertion per requirement; no test file uses jsdom annotation (all default node env)</done>
</task>

</tasks>

<verification>
```bash
cd C:/Users/chase/projects/tangle && grep -n "^export function" src/lib/parser.ts
```
Must show 4 lines: buildExternalLinkMap, extractNamedRanges, extractReferences, parseWorkbook.

```bash
cd C:/Users/chase/projects/tangle && npm test 2>&1 | tail -10
```
Must show all tests passed, exit code 0.

```bash
cd C:/Users/chase/projects/tangle && npx tsc --noEmit 2>&1
```
Must exit 0 with zero TypeScript errors.
</verification>

<success_criteria>
- `src/lib/parser.ts` exports `buildExternalLinkMap`, `extractNamedRanges`, `extractReferences` (3 new exports, no other changes)
- `npx tsc --noEmit` exits 0
- `npm test` exits 0 with all tests passing
- `tests/unit/parser.test.ts` exists and contains tests explicitly labeled PARSE-01 through PARSE-08
- All assertions in parser.test.ts pass: cross-sheet (unquoted/quoted), external ref (bracketed/numeric index), named ranges (detection/dedup), workload metrics
</success_criteria>

<output>
After completion, create `.planning/phases/02-parser-unit-tests/02-01-SUMMARY.md` following the summary template.
</output>
