---
phase: 03-graph-unit-tests
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - tests/unit/graph.test.ts
autonomous: true
requirements:
  - GRAPH-01
  - GRAPH-02
  - GRAPH-03
  - GRAPH-04

must_haves:
  truths:
    - "`npm test` passes with all GRAPH-01 through GRAPH-04 describe blocks green"
    - "`buildGraph()` with a same-workbook topology returns exactly N sheet nodes (one per uploaded sheet, zero external nodes)"
    - "`buildGraph()` with a cross-sheet ref returns exactly 1 edge with `edgeKind: 'internal'`"
    - "`buildGraph()` with both workbooks uploaded returns an edge with `edgeKind: 'cross-file'`"
    - "`buildGraph()` with an unrecognized target workbook returns an edge with `edgeKind: 'external'`"
    - "Passing a `hiddenFiles` Set causes that workbook's sheet nodes to be absent from the result"
  artifacts:
    - tests/unit/graph.test.ts (created, contains GRAPH-01 through GRAPH-04 describe blocks)
  key_links:
    - "`makeWorkbook()` factory produces valid `WorkbookFile` objects that `buildGraph()` accepts without error"
    - "Edge kind assertions read `edge.data.edgeKind` directly (typed as `EdgeKind`)"
    - "GRAPH-01 node count excludes external file nodes by filtering `!n.data.isExternal && !n.data.isFileNode`"
---

<objective>
Create `tests/unit/graph.test.ts` with a shared `makeWorkbook()` factory and test coverage for GRAPH-01 through GRAPH-04: node count correctness, edge count correctness, edge kind classification (all four kinds), and hidden file exclusion.

Purpose: Prove that `buildGraph()` correctly constructs the graph data structure — right nodes, right edges, right classification — which is the core correctness guarantee of the app.
Output: `tests/unit/graph.test.ts` with 4 describe blocks, all passing under `npm test`.
</objective>

<execution_context>
@C:/Users/chase/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/chase/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md

<interfaces>
<!-- Key types and contracts extracted from source. Executor uses these directly — no codebase exploration needed. -->

From src/types.ts:
```typescript
export interface SheetReference {
  targetWorkbook: string | null; // null = same workbook
  targetSheet: string;
  cells: string[];
  formula: string;
  sourceCell: string;
  namedRangeName?: string;
}

export interface SheetWorkload {
  totalFormulas: number;
  withinSheetRefs: number;
  crossSheetRefs: number;
  crossFileRefs: number;
}

export interface ParsedSheet {
  workbookName: string;
  sheetName: string;
  references: SheetReference[];
  workload: SheetWorkload;
}

export interface WorkbookFile {
  id: string;
  name: string;
  sheets: ParsedSheet[];
  namedRanges: NamedRange[];  // use [] for all graph tests
}
```

From src/lib/graph.ts (exports):
```typescript
export function buildGraph(
  workbooks: WorkbookFile[],
  layoutMode: LayoutMode = 'graph',
  hiddenFiles: Set<string> = new Set(),
  showNamedRanges: boolean = false,
): { nodes: Node<NodeData>[]; edges: Edge<EdgeData>[] }

export type NodeData = {
  label: string;
  workbookName: string;
  sheetName: string;
  isExternal: boolean;
  isFileNode: boolean;
  isNamedRange: boolean;
  namedRangeName?: string;
  outgoingCount: number;
  incomingCount: number;
  workload: SheetWorkload | null;
}

export type EdgeKind = 'internal' | 'cross-file' | 'external' | 'named-range';

export type EdgeData = {
  references: EdgeReference[];
  refCount: number;
  edgeKind: EdgeKind;
}

export type LayoutMode = 'graph' | 'grouped' | 'overview';
```

Key implementation facts (verified from source reading):
- `buildGraph()` uses ALL workbooks for name normalization but only VISIBLE workbooks for Pass 1 (node registration) and Pass 2 (edge building)
- `hiddenFiles` is a `Set<string>` of workbook names — exact string match (e.g., `'FileB.xlsx'`)
- `isExternal` is set to `true` for file-level nodes created for unrecognized or hidden target workbooks
- `isFileNode` is `true` for file-level nodes (external or hidden); `false` for sheet-level nodes
- `edgeKind` classification at lines 134–138: `isSameWb` → `'internal'`; else `targetIsUploaded` → `'cross-file'`; else `'external'`
- Node ID format: sheet nodes = `"WorkbookName.xlsx::SheetName"`, file nodes = `"[file]WorkbookName.xlsx"`
- A cross-file edge requires BOTH workbooks to be in the `workbooks` array (even if one is hidden). The `normWb()` function strips extension and lowercases — use exact same filename string in both the `WorkbookFile.name` and the `SheetReference.targetWorkbook` to avoid normalization surprises.
</interfaces>

<pitfalls>
<!-- Critical pitfalls verified from graph.ts source reading — heed these. -->

**Pitfall 1 — Node count includes external file nodes:**
`buildGraph()` creates a file-level external node for any reference whose `targetWorkbook` is not in the uploaded list. For GRAPH-01, use a same-workbook-only topology (no external refs) so `nodes.length === sheets.length`. Alternatively: filter `nodes.filter(n => !n.data.isExternal && !n.data.isFileNode)`.

**Pitfall 2 — cross-file requires exact name match:**
The `normWb()` function lowercases and strips `.xlsx` extension. If `SheetReference.targetWorkbook` is `'WorkbookB.xlsx'` but the uploaded workbook's `name` is `'workbookb.xlsx'`, they still match. But if the extension is absent from one side (e.g., `'WorkbookB'`), they also match. Use the exact same string on both sides to be unambiguous.

**Pitfall 3 — Hidden file node absence vs edge absence:**
For GRAPH-04, assert (a) no sheet-level node for the hidden workbook (`workbookName === hiddenWbName && !isFileNode`), and (b) no edge whose `source` or `target` equals a hidden sheet's node ID (format: `"FileB.xlsx::Sheet1"`). File-level external nodes for hidden workbooks MAY still appear (they represent the reference target) — this is by design and GRAPH-04 does not require their absence.

**Pitfall 5 — Self-edge skip:**
If source sheet and target sheet resolve to the same node ID, the edge is skipped at line 132. Ensure fixture topologies have distinct source and target sheets.

**Anti-pattern:**
Do NOT use `// @vitest-environment jsdom` in this file — graph.ts has no DOM dependencies. Do NOT use the word "annotation" in test comments (triggers false @vitest-environment module resolution, discovered in Phase 2).
</pitfalls>
</context>

<tasks>

<task type="tdd">
  <name>Task 1: Create graph.test.ts with factory + GRAPH-01 and GRAPH-02</name>
  <files>tests/unit/graph.test.ts</files>
  <action>
Create `tests/unit/graph.test.ts`. No `@vitest-environment` directive at the top. Import style matches existing parser tests (named imports from vitest, no globals).

**File header and imports:**
```typescript
// tests/unit/graph.test.ts
// Environment: node (default from vitest.config.ts — no override needed)
// Covers: GRAPH-01, GRAPH-02, GRAPH-03, GRAPH-04, GRAPH-05, GRAPH-06, GRAPH-07
import { describe, it, expect, beforeAll } from 'vitest'
import type { WorkbookFile, SheetReference, SheetWorkload } from '../../src/types'
import { buildGraph, type NodeData, type EdgeData, type EdgeKind } from '../../src/lib/graph'
```

**Shared factory (place before any describe block):**
```typescript
const zeroWorkload: SheetWorkload = {
  totalFormulas: 0, withinSheetRefs: 0, crossSheetRefs: 0, crossFileRefs: 0,
}

function makeWorkbook(
  name: string,
  sheets: { sheetName: string; refs?: SheetReference[] }[],
): WorkbookFile {
  return {
    id: name,
    name,
    namedRanges: [],
    sheets: sheets.map(({ sheetName, refs = [] }) => ({
      workbookName: name,
      sheetName,
      references: refs,
      workload: { ...zeroWorkload },
    })),
  }
}
```

**GRAPH-01 describe block** — same-workbook-only topology (no external refs, so node count equals sheet count):
```typescript
describe('GRAPH-01: one node per uploaded sheet (standard layout)', () => {
  it('single workbook with two sheets produces exactly two nodes', () => {
    const wb = makeWorkbook('FileA.xlsx', [
      { sheetName: 'Sheet1' },
      { sheetName: 'Sheet2' },
    ])
    const { nodes } = buildGraph([wb])
    // No external refs in this topology — all nodes are sheet nodes
    expect(nodes).toHaveLength(2)
    // Each node corresponds to an uploaded sheet (not external)
    expect(nodes.every(n => !n.data.isExternal)).toBe(true)
  })

  it('two workbooks with three sheets total produce exactly three nodes', () => {
    const wbA = makeWorkbook('FileA.xlsx', [{ sheetName: 'Sheet1' }, { sheetName: 'Sheet2' }])
    const wbB = makeWorkbook('FileB.xlsx', [{ sheetName: 'Data' }])
    const { nodes } = buildGraph([wbA, wbB])
    const sheetNodes = nodes.filter(n => !n.data.isExternal && !n.data.isFileNode)
    expect(sheetNodes).toHaveLength(3)
  })
})
```

**GRAPH-02 describe block** — topology with one cross-sheet ref produces exactly one edge:
```typescript
describe('GRAPH-02: edges created for cross-sheet references', () => {
  it('one cross-sheet ref produces exactly one edge', () => {
    const crossSheetRef: SheetReference = {
      targetWorkbook: null,
      targetSheet: 'Sheet2',
      cells: ['A1'],
      formula: 'Sheet2!A1',
      sourceCell: 'A1',
    }
    const wb = makeWorkbook('FileA.xlsx', [
      { sheetName: 'Sheet1', refs: [crossSheetRef] },
      { sheetName: 'Sheet2' },
    ])
    const { edges } = buildGraph([wb])
    expect(edges).toHaveLength(1)
  })

  it('two refs from the same sheet to the same target are aggregated into one edge', () => {
    const ref1: SheetReference = {
      targetWorkbook: null, targetSheet: 'Sheet2', cells: ['A1'], formula: 'Sheet2!A1', sourceCell: 'A1',
    }
    const ref2: SheetReference = {
      targetWorkbook: null, targetSheet: 'Sheet2', cells: ['B1'], formula: 'Sheet2!B1', sourceCell: 'B1',
    }
    const wb = makeWorkbook('FileA.xlsx', [
      { sheetName: 'Sheet1', refs: [ref1, ref2] },
      { sheetName: 'Sheet2' },
    ])
    const { edges } = buildGraph([wb])
    // Both refs share the same source→target pair → aggregated into one edge
    expect(edges).toHaveLength(1)
    expect(edges[0].data.refCount).toBe(2)
  })
})
```

Run `npm test` after writing both describe blocks. Both must be green before proceeding to Task 2.
  </action>
  <verify>
    <automated>cd /c/Users/chase/projects/tangle && npm test -- --reporter=verbose 2>&1 | tail -40</automated>
  </verify>
  <done>
    `npm test` passes. `GRAPH-01` describe block has 2 passing tests. `GRAPH-02` describe block has 2 passing tests. No TypeScript compile errors.
  </done>
</task>

<task type="tdd">
  <name>Task 2: Add GRAPH-03 (edge kind classification) and GRAPH-04 (hidden files)</name>
  <files>tests/unit/graph.test.ts</files>
  <action>
Append two more describe blocks to `tests/unit/graph.test.ts`.

**GRAPH-03 describe block** — all four edge kinds in one file, using topology-driven fixture design:

The topology:
- `wbA` has `Sheet1` with a cross-sheet ref to `Sheet2` (internal), a cross-file ref to `wbB::Sheet1` (cross-file), and an external ref to `External.xlsx::Data` (external)
- `wbB` has `Sheet1` (no refs)
- Both `wbA` and `wbB` are uploaded; `External.xlsx` is not uploaded

Named range edges are tested in GRAPH-07 (Plan 02). GRAPH-03 covers the other three kinds here plus the named-range kind using `showNamedRanges: true`.

```typescript
describe('GRAPH-03: edge kind classification', () => {
  const crossSheetRef: SheetReference = {
    targetWorkbook: null,
    targetSheet: 'Sheet2',
    cells: ['A1'],
    formula: 'Sheet2!A1',
    sourceCell: 'A1',
  }
  const crossFileRef: SheetReference = {
    targetWorkbook: 'FileB.xlsx',
    targetSheet: 'Sheet1',
    cells: ['C3'],
    formula: '[FileB.xlsx]Sheet1!C3',
    sourceCell: 'B1',
  }
  const externalRef: SheetReference = {
    targetWorkbook: 'External.xlsx',
    targetSheet: 'Data',
    cells: ['D5'],
    formula: '[External.xlsx]Data!D5',
    sourceCell: 'C1',
  }
  const namedRangeRef: SheetReference = {
    targetWorkbook: null,
    targetSheet: 'Sheet2',
    cells: ['A1:A10'],
    formula: 'MyRange',
    sourceCell: 'D1',
    namedRangeName: 'MyRange',
  }

  const wbA = makeWorkbook('FileA.xlsx', [
    { sheetName: 'Sheet1', refs: [crossSheetRef, crossFileRef, externalRef] },
    { sheetName: 'Sheet2' },
  ])
  const wbB = makeWorkbook('FileB.xlsx', [{ sheetName: 'Sheet1' }])
  const wbWithNR = makeWorkbook('FileA.xlsx', [
    { sheetName: 'Sheet1', refs: [namedRangeRef] },
    { sheetName: 'Sheet2' },
  ])

  it("internal edge: same-workbook cross-sheet ref has edgeKind 'internal'", () => {
    const { edges } = buildGraph([wbA, wbB])
    const internalEdge = edges.find(e => e.data.edgeKind === 'internal')
    expect(internalEdge).toBeDefined()
  })

  it("cross-file edge: ref to uploaded workbook has edgeKind 'cross-file'", () => {
    const { edges } = buildGraph([wbA, wbB])
    const crossFileEdge = edges.find(e => e.data.edgeKind === 'cross-file')
    expect(crossFileEdge).toBeDefined()
  })

  it("external edge: ref to non-uploaded workbook has edgeKind 'external'", () => {
    // Upload only wbA — External.xlsx is not uploaded
    const { edges } = buildGraph([wbA])
    // crossFileRef now also becomes external (FileB.xlsx not uploaded)
    const externalEdges = edges.filter(e => e.data.edgeKind === 'external')
    expect(externalEdges.length).toBeGreaterThan(0)
  })

  it("named-range edge: ref with namedRangeName has edgeKind 'named-range' when showNamedRanges=true", () => {
    const { edges } = buildGraph([wbWithNR], 'graph', new Set(), true)
    const nrEdge = edges.find(e => e.data.edgeKind === 'named-range')
    expect(nrEdge).toBeDefined()
  })
})
```

**GRAPH-04 describe block** — hidden file exclusion:

```typescript
describe('GRAPH-04: hidden files excluded from nodes and edges', () => {
  const crossFileRef: SheetReference = {
    targetWorkbook: 'FileB.xlsx',
    targetSheet: 'Sheet1',
    cells: ['A1'],
    formula: '[FileB.xlsx]Sheet1!A1',
    sourceCell: 'A1',
  }
  const wbA = makeWorkbook('FileA.xlsx', [{ sheetName: 'Sheet1', refs: [crossFileRef] }])
  const wbB = makeWorkbook('FileB.xlsx', [{ sheetName: 'Sheet1' }, { sheetName: 'Sheet2' }])

  it('hidden workbook sheet nodes are absent from the result', () => {
    const hidden = new Set(['FileB.xlsx'])
    const { nodes } = buildGraph([wbA, wbB], 'graph', hidden)
    // No sheet-level node should belong to FileB.xlsx
    const fileBSheetNodes = nodes.filter(
      n => n.data.workbookName === 'FileB.xlsx' && !n.data.isFileNode,
    )
    expect(fileBSheetNodes).toHaveLength(0)
  })

  it('edges originating from a hidden workbook are absent', () => {
    // Hide wbA — its Sheet1 has the outgoing ref
    const hidden = new Set(['FileA.xlsx'])
    const { edges } = buildGraph([wbA, wbB], 'graph', hidden)
    // No edge should have source equal to FileA.xlsx::Sheet1
    const filAEdges = edges.filter(e => e.source.startsWith('FileA.xlsx::'))
    expect(filAEdges).toHaveLength(0)
  })

  it('non-hidden workbook nodes are still present when one file is hidden', () => {
    const hidden = new Set(['FileB.xlsx'])
    const { nodes } = buildGraph([wbA, wbB], 'graph', hidden)
    const fileANodes = nodes.filter(
      n => n.data.workbookName === 'FileA.xlsx' && !n.data.isFileNode,
    )
    expect(fileANodes).toHaveLength(1)
  })
})
```

Run `npm test` and confirm all 4 describe blocks pass.
  </action>
  <verify>
    <automated>cd /c/Users/chase/projects/tangle && npm test -- --reporter=verbose 2>&1 | tail -50</automated>
  </verify>
  <done>
    `npm test` passes. All 4 describe blocks (GRAPH-01, GRAPH-02, GRAPH-03, GRAPH-04) are green. No regressions in parser tests. Total test count has increased from 22 (parser suite) by the number of new graph tests.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
- `npm test` runs the full unit test suite (parser + graph) with zero failures
- `tests/unit/graph.test.ts` exists and contains 4 describe blocks
- GRAPH-01: 2 tests, GRAPH-02: 2 tests, GRAPH-03: 4 tests, GRAPH-04: 3 tests (all green)
- No TypeScript compile errors (Vitest runs tsc implicitly)
- The existing 22 parser tests remain green (no regressions)
</verification>

<success_criteria>
- `npm test` output shows all tests passing, including the new GRAPH-01 through GRAPH-04 describe blocks
- Each describe block title matches its requirement ID for traceability
- `tests/unit/graph.test.ts` imports only from `../../src/types` and `../../src/lib/graph` (no SheetJS, no fixtures)
</success_criteria>

<output>
After completion, create `.planning/phases/03-graph-unit-tests/03-01-SUMMARY.md` following the summary template.
</output>
