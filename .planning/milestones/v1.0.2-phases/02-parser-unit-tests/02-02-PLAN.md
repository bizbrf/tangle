---
phase: 02-parser-unit-tests
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - tests/unit/parser.error.test.ts
autonomous: true
requirements:
  - PARSE-09
  - PARSE-10
  - PARSE-11

must_haves:
  truths:
    - "`npm test` passes all tests in `tests/unit/parser.error.test.ts` — empty workbook, corrupt file rejection, and circular refs all green"
    - "Empty workbook returns zero references and all-zero workload metrics (totalFormulas, withinSheetRefs, crossSheetRefs, crossFileRefs all === 0)"
    - "`parseWorkbook()` rejects (does not throw synchronously or hang) when given a corrupt .xlsx buffer — the promise is rejected with an Error"
    - "Calling `extractReferences()` on both sheets of circular.xlsx completes synchronously without hanging — no infinite loop or timeout"
  artifacts:
    - path: "tests/unit/parser.error.test.ts"
      provides: "Error-handling and edge-case unit tests for PARSE-09, PARSE-10, PARSE-11"
      contains: "@vitest-environment jsdom"
  key_links:
    - from: "tests/unit/parser.error.test.ts"
      to: "src/lib/parser.ts"
      via: "import { parseWorkbook, extractReferences } from '../../src/lib/parser'"
      pattern: "import.*parseWorkbook.*extractReferences.*from.*parser"
    - from: "tests/unit/parser.error.test.ts"
      to: "tests/fixtures/index.ts"
      via: "import { FIXTURES } from '../fixtures/index'"
      pattern: "import.*FIXTURES.*from.*fixtures"
    - from: "parseWorkbook() test"
      to: "jsdom FileReader"
      via: "@vitest-environment jsdom per-file annotation"
      pattern: "@vitest-environment jsdom"
---

<objective>
Write `tests/unit/parser.error.test.ts` to cover the three edge-case and error-handling requirements: empty workbooks, malformed file rejection, and circular references. This file uses a per-file jsdom environment annotation for the `parseWorkbook()` rejection test — the only test in the entire phase that requires a DOM `FileReader`.

Purpose: The reference extraction core is only trustworthy if it handles bad inputs gracefully. Empty workbooks, corrupt files, and circular sheet references are realistic user scenarios that must be confirmed not to crash or hang the application.
Output: `tests/unit/parser.error.test.ts` with three describe blocks covering PARSE-09, PARSE-10, PARSE-11.
</objective>

<execution_context>
@C:/Users/chase/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/chase/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-parser-unit-tests/02-RESEARCH.md
@.planning/phases/02-parser-unit-tests/02-01-SUMMARY.md
</context>

<interfaces>
<!-- From src/lib/parser.ts (exported in Plan 02-01): -->
<!-- export function extractReferences(sheet, sheetName, workbookName, linkMap, namedRangeMap): { references, workload } -->
<!-- export function parseWorkbook(file: File, fileId: string): Promise<WorkbookFile> -->
<!--   - Uses new FileReader() internally — requires jsdom environment -->
<!--   - Wraps XLSX.read() in try/catch; rejects on parse error -->
<!--   - jsdom 28.1.0 provides FileReader, File, Blob (confirmed in research) -->

<!-- From tests/fixtures/index.ts: -->
<!-- FIXTURES.empty     → tests/fixtures/empty.xlsx    (0 formula cells, Sheet1 has plain values only) -->
<!-- FIXTURES.malformed → tests/fixtures/malformed.xlsx (PK header + garbage bytes — XLSX.read throws) -->
<!-- FIXTURES.circular  → tests/fixtures/circular.xlsx  (Sheet1.A1.f='Sheet2!A1', Sheet2.A1.f='Sheet1!A1') -->

<!-- CRITICAL NOTES (from RESEARCH.md): -->
<!-- - `@vitest-environment jsdom` annotation goes on the FIRST LINE of the file (before all imports) -->
<!-- - PARSE-09 (empty workbook) can use node env — extractReferences() directly, no FileReader needed -->
<!-- - PARSE-10 (corrupt file) MUST use jsdom — calls parseWorkbook() which uses new FileReader() -->
<!-- - PARSE-11 (circular refs) uses node env — extractReferences() is pure regex, no recursion risk -->
<!-- - Malformed file error message varies by SheetJS version — use .rejects.toThrow() NOT .rejects.toThrow('specific message') -->
<!-- - The @vitest-environment jsdom annotation makes the ENTIRE file use jsdom, including PARSE-09 and PARSE-11 tests -->
<!--   This is acceptable — jsdom is a superset of node for these tests (no DOM-specific behavior required) -->
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Write parser.error.test.ts covering PARSE-09, PARSE-10, PARSE-11</name>
  <files>
    tests/unit/parser.error.test.ts
  </files>
  <action>
    Create `tests/unit/parser.error.test.ts`. The `@vitest-environment jsdom` annotation MUST be on the first line of the file (before any imports or comments). This enables `FileReader` for the PARSE-10 test.

    ```typescript
    // @vitest-environment jsdom
    // tests/unit/parser.error.test.ts
    // Environment: jsdom (per-file annotation — required for FileReader in parseWorkbook() tests)
    // Covers: PARSE-09 (empty workbook), PARSE-10 (corrupt file rejection), PARSE-11 (circular refs)
    import * as XLSX from 'xlsx'
    import { readFileSync } from 'node:fs'
    import { describe, it, expect, beforeAll } from 'vitest'
    import { FIXTURES } from '../fixtures/index'
    import { parseWorkbook, extractReferences } from '../../src/lib/parser'

    // ── PARSE-09: Empty workbook ─────────────────────────────────────────────────
    describe('extractReferences — empty workbook (PARSE-09)', () => {
      it('returns zero references for an empty workbook', () => {
        // empty.xlsx: Sheet1 has plain values, no formula cells
        const buf = readFileSync(FIXTURES.empty)
        const wb = XLSX.read(buf, { type: 'buffer', cellFormula: true })
        const { references } = extractReferences(
          wb.Sheets['Sheet1'], 'Sheet1', 'empty.xlsx', new Map(), new Map()
        )
        expect(references).toHaveLength(0)
      })

      it('returns all-zero workload metrics for an empty workbook', () => {
        const buf = readFileSync(FIXTURES.empty)
        const wb = XLSX.read(buf, { type: 'buffer', cellFormula: true })
        const { workload } = extractReferences(
          wb.Sheets['Sheet1'], 'Sheet1', 'empty.xlsx', new Map(), new Map()
        )
        expect(workload.totalFormulas).toBe(0)
        expect(workload.crossSheetRefs).toBe(0)
        expect(workload.crossFileRefs).toBe(0)
        expect(workload.withinSheetRefs).toBe(0)
      })
    })

    // ── PARSE-10: Corrupt file rejection ─────────────────────────────────────────
    describe('parseWorkbook — malformed file (PARSE-10)', () => {
      it('rejects with an error (not a crash) when given a corrupt .xlsx file', async () => {
        // malformed.xlsx: PK header + garbage bytes — XLSX.read() throws on parse
        // parseWorkbook() wraps XLSX.read() in try/catch and calls reject(err)
        // jsdom provides File and FileReader globals needed by parseWorkbook()
        const buf = readFileSync(FIXTURES.malformed)
        const file = new File([buf], 'malformed.xlsx')
        // Do NOT assert on error message text — SheetJS error messages vary by version
        await expect(parseWorkbook(file, 'test-id')).rejects.toThrow()
      })

      it('promise is rejected, not undefined and not hanging', async () => {
        const buf = readFileSync(FIXTURES.malformed)
        const file = new File([buf], 'malformed.xlsx')
        let caught: unknown = null
        try {
          await parseWorkbook(file, 'test-id')
        } catch (err) {
          caught = err
        }
        // The error must be an Error instance (not null, not undefined)
        expect(caught).toBeInstanceOf(Error)
      })
    })

    // ── PARSE-11: Circular references ────────────────────────────────────────────
    describe('extractReferences — circular references (PARSE-11)', () => {
      let wb: XLSX.WorkBook

      beforeAll(() => {
        // circular.xlsx: Sheet1.A1.f = 'Sheet2!A1', Sheet2.A1.f = 'Sheet1!A1'
        // extractReferences() is pure regex — no traversal, no recursion.
        // Both sheets must extract without hanging.
        const buf = readFileSync(FIXTURES.circular)
        wb = XLSX.read(buf, { type: 'buffer', cellFormula: true })
      })

      it('PARSE-11: Sheet1 extracts circular ref to Sheet2 without hanging', () => {
        const { references } = extractReferences(
          wb.Sheets['Sheet1'], 'Sheet1', 'circular.xlsx', new Map(), new Map()
        )
        expect(references).toHaveLength(1)
        expect(references[0].targetSheet).toBe('Sheet2')
        expect(references[0].targetWorkbook).toBeNull()
      })

      it('PARSE-11: Sheet2 extracts circular ref back to Sheet1 without hanging', () => {
        const { references } = extractReferences(
          wb.Sheets['Sheet2'], 'Sheet2', 'circular.xlsx', new Map(), new Map()
        )
        expect(references).toHaveLength(1)
        expect(references[0].targetSheet).toBe('Sheet1')
        expect(references[0].targetWorkbook).toBeNull()
      })

      it('PARSE-11: workload metrics are correct for each circular sheet', () => {
        const { workload: w1 } = extractReferences(
          wb.Sheets['Sheet1'], 'Sheet1', 'circular.xlsx', new Map(), new Map()
        )
        expect(w1.totalFormulas).toBe(1)
        expect(w1.crossSheetRefs).toBe(1)

        const { workload: w2 } = extractReferences(
          wb.Sheets['Sheet2'], 'Sheet2', 'circular.xlsx', new Map(), new Map()
        )
        expect(w2.totalFormulas).toBe(1)
        expect(w2.crossSheetRefs).toBe(1)
      })
    })
    ```

    Run the full test suite to confirm all tests pass — both the existing Phase 1 smoke tests, Plan 02-01 parser tests, and the new error tests:
    ```bash
    cd C:/Users/chase/projects/tangle && npm test 2>&1
    ```

    Troubleshooting:
    - "ReferenceError: FileReader is not defined" → `@vitest-environment jsdom` annotation is missing or not on the first line of the file (it must be the very first line, even before blank lines)
    - `parseWorkbook(file, 'test-id')` resolves instead of rejecting → malformed.xlsx was not generated correctly; verify `npm run fixtures:generate` was run and malformed.xlsx contains garbage bytes (not a valid zip)
    - PARSE-11 tests hang / timeout → The extractReferences function is doing graph traversal (should not be); check that the circular.xlsx fixture has Sheet1 and Sheet2 with correct formulas; the function reads cell.f strings via regex only
    - "Cannot find module '../../src/lib/parser' extractReferences" → Plan 02-01 was not completed; the `export` keyword must be added to extractReferences in parser.ts first
  </action>
  <verify>
    <automated>
      cd C:/Users/chase/projects/tangle && npm test 2>&1
    </automated>
    Must show all tests passing (Phase 1 smoke tests + Plan 02-01 parser tests + new error tests). Zero failures. Exit code 0.

    Confirm the jsdom annotation is present:
    ```bash
    cd C:/Users/chase/projects/tangle && head -1 tests/unit/parser.error.test.ts
    ```
    Must print exactly: `// @vitest-environment jsdom`
  </verify>
  <done>`npm test` exits 0 with all tests passing; `tests/unit/parser.error.test.ts` exists with `@vitest-environment jsdom` on line 1; PARSE-09 (empty workbook zero metrics), PARSE-10 (corrupt file rejects), and PARSE-11 (circular refs complete) all pass</done>
</task>

</tasks>

<verification>
```bash
cd C:/Users/chase/projects/tangle && npm test 2>&1 | tail -10
```
Must show all tests passed, exit code 0.

```bash
cd C:/Users/chase/projects/tangle && npm test 2>&1 | grep -E "parser\.error|parser\.test|smoke"
```
Must show all three test files listed as passing.

```bash
cd C:/Users/chase/projects/tangle && npm run test:coverage 2>&1 | grep -E "parser\.ts|All files"
```
Coverage report must exist and show parser.ts coverage (non-zero line coverage).
</verification>

<success_criteria>
- `npm test` exits 0 with all tests passing — Phase 1 smoke tests plus all PARSE-01 through PARSE-11 tests green
- `tests/unit/parser.error.test.ts` exists with `// @vitest-environment jsdom` as line 1
- PARSE-09: empty workbook returns [] references and all-zero workload
- PARSE-10: parseWorkbook() promise rejects (instanceof Error) for corrupt file — does not crash or hang
- PARSE-11: both sheets of circular.xlsx extract their references; no timeout or infinite loop
- `npm run test:coverage` completes and shows parser.ts in coverage report
</success_criteria>

<output>
After completion, create `.planning/phases/02-parser-unit-tests/02-02-SUMMARY.md` following the summary template.
</output>
